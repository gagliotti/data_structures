\documentclass[12pt,table,xcolor={dvipsnames}]{beamer}
%\usetheme{Pittsburgh}
\usecolortheme{seagull}
%\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage[brazilian]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows, positioning}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{amssymb}
%\usepackage{lstlinebgrd}
\usepackage{graphicx}
\usepackage{wasysym}
\subtitle{Pilha Encadeada e Fila}
\title{Estruturas de Dados}
%\setbeamercovered{transparent}
\setbeamertemplate{navigation symbols}{}
%\logo{\includegraphics[scale=0.015]{Brasao_UFSC.png}\includegraphics[scale=0.2]{brasao_PPGCC.jpg}}
\institute{Departamento de Computação \\ Prof. Martín Vigil \\ Adaptado de prof. Jean Martina e Aldo Wangenheim}
\date{2020.1}
\subject{}
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
 height=\paperheight]{../reusable_images/fundo_UFSC.png}}
\begin{document}
 
 {
  \usebackgroundtemplate{\includegraphics[width=\paperwidth,
   height=\paperheight]{../reusable_images/fundo_capa.png}}
  \begin{frame}
   \titlepage
   %\includegraphics[scale=0.3]{../reusable_images/brasao_INE.png}
  \end{frame}
 }


\begin{frame}[fragile]{Extensões do conceito de Lista Encadeada}
\begin{itemize}
\item A ideia da Lista Encadeada vista até agora é o modelo mais geral e simples;
\item Pode ser especializada e estendida das mais variadas formas;
\item Especializada:
\begin{itemize}
\item Pilhas;
\item Filas;
\end{itemize}
\item Estendida:
\begin{itemize}
\item Listas Duplamente Encadeadas;
\item Listas Circulares Simples e Duplas.
\end{itemize}
\end{itemize}
\end{frame}



%%%%
\begin{frame}[fragile]{Conceito de Pilhas}
 \setbeamercovered{invisible}
 \begin{columns}
\column{.5\textwidth}

 
 \begin{block}{Pilha}
  É uma estrutura de dados cujo funcionamento é inspirado no conceito “natural” de empilhar, onde o \textcolor{blue}{primeiro a entrar é o último a sair} (LIFO = \textit{last in, first out}).
 \end{block}
 
 
\column{.5\textwidth}
  \begin{center}
   \begin{tikzpicture}[list/.style={rectangle,
    draw=black, fill=green!5,minimum width=0.75cm,
    minimum height = .5cm}, >=stealth, start chain]
   
   \node<1-13>[list,on chain]  (B1)  {};
   \node<1-13>[list,on chain] (B2) [below =0cm of B1] {};
   \node<1-13>[list,on chain] (B3)  [below =0cm of B2] {};
   \node<1-13>[list,on chain] (B4)  [below =0cm of B3] {};
   \node<1-13>[list,on chain] (B5) [below =0cm of B4] {};
   \node<1,13>[] (PV) [above= of B1] {Pilha Vazia};
   
   \node<2>[] (C1) [above left= of B1] {Empilhar 20};
   \draw<2>[->] (C1.east) to [out=45, in=90] (B5.center);
   
   \node<3-12>[list,on chain] (B5) [below =0cm of B4] {20};
   \node<3>[] (C1) [above left= of B1] {Empilhar 55};
   \draw<3>[->] (C1.east) to [out=45, in=90] (B4.center);
   
   \node<4-11>[list,on chain] (B4) [below =0cm of B3] {55};
   \node<4>[] (C1) [above left= of B1] {Empilhar 4};
   \draw<4>[->] (C1.east) to [out=45, in=90] (B3.center);

   \node<5-10>[list,on chain] (B3) [below =0cm of B2] {4};
   \node<5>[] (C1) [above left= of B1] {Empilhar 12};
   \draw<5>[->] (C1.east) to [out=45, in=90] (B2.center);

   \node<6-9>[list,on chain] (B2) [below =0cm of B1] {12};
   \node<6>[] (C1) [above left= of B1] {Empilhar 7};
   \draw<6>[->] (C1.east) to [out=45, in=90] (B1.center);

   \node<7-8>[list,on chain] (B1) [above =0cm of B2] {7};
   \node<8>[] (D1) [above right= of B1] {Desempilhar 7};
   \draw<8>[->] (B1.north) to [out=90, in=180] (D1.west);
   
   \node<9>[] (D1) [above right= of B1] {Desempilhar 12};
   \draw<9>[->] (B2.north) to [out=90, in=180] (D1.west);
   
   \node<10>[] (D1) [above right= of B1] {Desempilhar 4};
   \draw<10>[->] (B3.north) to [out=90, in=180] (D1.west);
   
   \node<11>[] (D1) [above right= of B1] {Desempilhar 55};
   \draw<11>[->] (B4.north) to [out=90, in=180] (D1.west);   
   
   \node<12>[] (D1) [above right= of B1] {Desempilhar 20};
   \draw<12>[->] (B5.north) to [out=90, in=180] (D1.west);   

   \end{tikzpicture}
  \end{center}
 \end{columns}
\end{frame}

%%%%





\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item {\color{red} Pilha Vazia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-2}
\cellcolor{GreenYellow}  & \multicolumn{1}{|p{.5cm}|} {-1} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {0} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}   & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {1} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {2} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  & &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {3} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen}  & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {4} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}<0>[fragile]{Pilhas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item {\color{red} Pilha Cheia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Pilhas Encadeadas}
\setbeamercovered{invisible}
\begin{columns}
\column{.25\textwidth}
  \begin{center}
   \begin{tikzpicture}[list/.style={rectangle,
 draw=black, fill=green!5,minimum width=0.75cm,
 minimum height = .5cm}, >=stealth, start chain]

\node<1>[list,on chain]  (B1)  {};
\node<1>[list,on chain] (B2) [below =0cm of B1] {};
\node<1>[list,on chain] (B5) [below =0cm of B4] {20};
\node<1>[list,on chain] (B4) [below =0cm of B3] {55};
\node<1>[list,on chain] (B3) [below =0cm of B2] {4};

\node<1>[] (L1) [left=.5cm of B5]{\color{red}Base da pilha};
\node<1>[] (L2) [left=.5cm of B3]{\color{red}Topo da pilha};
\draw<1>[red,->] (L1) -- (B5);
\draw<1>[red,->] (L2) -- (B3);

\end{tikzpicture}
\end{center}
\column{.75\textwidth}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, >=stealth, start chain]

  \node[list,on chain] (H) {3};
  \node at (2,0) (T) {\color{red}Cabeça};
  \draw [red,<-] (H) -- (T);
  \node[list,on chain] (A) [below right=of H] {};
  
  \node[draw,on chain] (E1) [left=of A]{4};
  
  
  \node (T2)[align=left,right=of A] {\color{red}{Topo da pilha}};
  \draw [red,<-] (A) -- (T2);
  
  
  \node[list,on chain] (B) [below =of A] {};
   \node[draw,on chain] (E2) [left=of B]{55};
  \node[list,on chain] (C) [below =of B] {};
    \node[draw,on chain] (E3) [left=of C]{20};
  
   \node (U1)[align=left,right=of B] {\color{red}Elemento};
   \draw [red,<-] (A) -- (U1); 
   \draw [red,<-] (B) -- (U1); 
   \draw [red,<-] (C) -- (U1); 
    
    
   \node (U2)[align=left,right=of C] {\color{red}{Base da pilha}};
  \draw [red,<-] (C) -- (U2.west); 
  
    
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below =of C] {null*};
  \node  (T3)[left=of D] {\color{red}Marcador Fim};
  \draw  [red,<-] (D) -- (T3);  
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);

 \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+5,\y2) -- (E1);  
\draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+5,\y2) -- (E2); 
\draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+5,\y2) -- (E3);
  
\end{tikzpicture}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Modelagem da Pilha}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Mesmas estruturas de uma lista encadeada:
\begin{itemize}
\item Estrutura Lista
\item Estrutura Elemento
\item Ponteiro genérico de dados.
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}




\begin{frame}[fragile]{Modelagem da Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Funcional:
\begin{itemize}
\item Inicializar a pilha.
\item Empilhar (\textit{\textbf{push}}) dado na pilha;
\item Desempilhar (\textit{\textbf{pop}}) dado da pilha;
\item Testar se a pilha está vazia;

\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializar ou limpar:
\begin{itemize}
\item inicializarPilha();
\item destruirPilha()
\end{itemize}
\item Testar se a pilha está vazia:
\begin{itemize}
\item bool pilhaVazia();
\end{itemize}
\item Colocar e retirar dados da pilha:
\begin{itemize}
\item push();
\item pop();
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{inicializarPilha}}
 \lstset{language=C++,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{OliveGreen}\ttfamily,
  breaklines=true,
  basicstyle=\ttfamily\footnotesize
 }
 \begin{itemize}
  \item Equivalente ao inicializarLista()
  \item Complexidade temporal $\Theta(1)$
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{destruirPilha}}
 \lstset{language=C++,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{OliveGreen}\ttfamily,
  breaklines=true,
  basicstyle=\ttfamily\footnotesize
 }
 \begin{itemize}
  \item Similar a destruirLista;
  \item Função genérica em C não consegue desalocar qualquer tipo de dado na pilha
  \item Complexidade temporal $\Theta(n)$
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{pilhaVazia}}
 \begin{itemize}
  \item Equivalente a verificar se o tamanho da lista é nulo
  \item Complexidade temporal $\Theta(1)$
 \end{itemize}      
\end{frame}

\begin{frame}[fragile]{Método \textit{push}}
 \begin{itemize}
  \item Equivalente a adicionaNoInicio na lista encadeada.
  \item Complexidade temporal $\Theta(1)$
 \end{itemize} 
\end{frame} 

\begin{frame}[fragile]{Método \textit{pop}}
 \begin{itemize}
  \item Equivalente a retiraNoInicio na lista encadeada.
  \item Complexidade temporal $\Theta(1)$
 \end{itemize} 
\end{frame} 

\begin{frame}[fragile]{Aplicações de Pilhas}
\begin{enumerate}
 \item Algoritmos de Busca em Profundidade com \textit{Backtracking} 
 \begin{itemize}
  \item Busca pela saída em labirintos
 \end{itemize}
 \item Chamada e retorno de funções na execução de um software
 \item Mais exemplos \tiny\url{http://jcsites.juniata.edu/faculty/kruse/cs240/stackapps.htm}
\end{enumerate}
\end{frame}

%voltar daqui pra cima

\begin{frame}<0>[fragile]{Trabalho Pilha Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe Pilha todas as operações vistas;
\item Implemente a pilha usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}


%%%%
\begin{frame}[fragile]{Conceito de Filas}
 \setbeamercovered{invisible}
 \begin{columns}
  \column{.5\textwidth}
  
  
\begin{block}{Fila}
 É uma estrutura de dados cujo funcionamento é inspirado no conceito “natural” de enfileiramento, onde o \color{blue}{primeiro a entrar é o primeiro a sair} \color{black}(FIFO = \textit{first in, first out}).
\end{block}
  
  \column{.5\textwidth}
  \begin{center}
   \begin{tikzpicture}[list/.style={rectangle,
    draw=black, fill=green!5,minimum width=0.75cm,
    minimum height = .75cm}, >=stealth, start chain]
   
   \node<1-7>[list,on chain]  (B1)  {{\uncover<3-7>{20}}};
   \node<1-8>[list,on chain] (B2) [right =0cm of B1] {{\uncover<4-8>{55}}};
   \node<1-9>[list,on chain] (B3)  [right =0cm of B2] {{\uncover<5-9>{4}}};
   \node<1-10>[list,on chain] (B4)  [right =0cm of B3] {{\uncover<6-10>{12}}};
   \node<1-11>[list,on chain] (B5) [right =0cm of B4] {{\uncover<7-11>{7}}};
   \node<1>[] (PV) [above= of B3] {Fila Vazia};
   
   \node<2>[] (C1) [below = of B3] {Enfilerar 20};
   \draw<2>[->] (C1.north) to [out=90, in=270] (B1.center);
   
   \node<3>[] (C1) [below = of B3] {Enfilerar 55};
   \draw<3>[->] (C1.north) to [out=90, in=270] (B2.center);

   \node<4>[] (C1) [below = of B3] {Enfilerar 4};
   \draw<4>[->] (C1.north) to [out=90, in=270] (B3.center);

   \node<5>[] (C1) [below = of B3] {Enfilerar 12};
   \draw<5>[->] (C1.north) to [out=90, in=270] (B4.center);
   
   \node<6>[] (C1) [below = of B3] {Enfilerar 7};
   \draw<6>[->] (C1.north) to [out=90, in=270] (B5.center);

   \node<7>[] (C1) [below = of B3] {Desenfilerar 20};
   \draw<7>[<-] (C1.north) to [out=90, in=270] (B1.south);

   \node<8->[list,on chain] (B6) [right =0cm of B5] {};
   \node<8>[] (C1) [below = of B4] {Desenfilerar 55};
   \draw<8>[<-] (C1.north) to [out=90, in=270] (B2.south);

   \node<9->[list,on chain] (B7) [right =0cm of B6] {};
   \node<9>[] (C1) [below = of B5] {Desenfilerar 4};
   \draw<9>[<-] (C1.north) to [out=90, in=270] (B3.south);
   
   \node<10->[list,on chain] (B8) [right =0cm of B7] {};
   \node<10>[] (C1) [below = of B6] {Desenfilerar 12};
   \draw<10>[<-] (C1.north) to [out=90, in=270] (B4.south);

   \node<11->[list,on chain] (B9) [right =0cm of B8] {};
   \node<11>[] (C1) [below = of B7] {Desenfilerar 7};
   \draw<11>[<-] (C1.north) to [out=90, in=270] (B5.south);

   \node<12>[] (PV) [above= of B7] {Fila Vazia};

   %\node<4-11>[list,on chain] (B4) [below =0cm of B3] {55};
   %\node<4>[] (C1) [above left= of B1] {Empilhar 4};
   %\draw<4>[->] (C1.east) to [out=45, in=90] (B3.center);
   
   %\node<5-10>[list,on chain] (B3) [below =0cm of B2] {4};
   %\node<5>[] (C1) [above left= of B1] {Empilhar 12};
   %\draw<5>[->] (C1.east) to [out=45, in=90] (B2.center);
   
   %\node<6-9>[list,on chain] (B2) [below =0cm of B1] {12};
   %\node<6>[] (C1) [above left= of B1] {Empilhar 7};
   %\draw<6>[->] (C1.east) to [out=45, in=90] (B1.center);
   
   %\node<7-8>[list,on chain] (B1) [above =0cm of B2] {7};
   %\node<8>[] (D1) [above right= of B1] {Desempilhar 7};
   %\draw<8>[->] (B1.north) to [out=90, in=180] (D1.west);
   
   %\node<9>[] (D1) [above right= of B1] {Desempilhar 12};
   %\draw<9>[->] (B2.north) to [out=90, in=180] (D1.west);
   
   %\node<10>[] (D1) [above right= of B1] {Desempilhar 4};
   %\draw<10>[->] (B3.north) to [out=90, in=180] (D1.west);
   
   %\node<11>[] (D1) [above right= of B1] {Desempilhar 55};
   %\draw<11>[->] (B4.north) to [out=90, in=180] (D1.west);   
   
   %\node<12>[] (D1) [above right= of B1] {Desempilhar 20};
   %\draw<12>[->] (B5.north) to [out=90, in=180] (D1.west);   
   
   \end{tikzpicture}
  \end{center}
 \end{columns}
\end{frame}





\begin{frame}{Fila}
Modelagem funcional
\begin{itemize}
 \item Inserir dado ao fim da fila (\textit{\textbf{enqueue}});
 \item Remover dado do início da fila (\textit{\textbf{dequeue}});
 \item Verificar tamanho da fila;
\end{itemize} 
\end{frame}


\begin{frame}{Fila usando Lista Encadeada}
 Modelagem funcional
 \begin{itemize}
  \item Inserir dado ao fim da fila (\textit{\textbf{enqueue}}) é \color{blue} $\Theta(1)$ \Large $\smiley$
  \item \color{black} \normalsize Remover dado do início da fila (\textit{\textbf{dequeue}}) é \color{red} $\Theta(n)$ \Large $\frownie$
  \item \color{black} \normalsize Verificar tamanho da fila é \color{blue}$\Theta(1)$ \Large $\smiley$
 \end{itemize} 
\end{frame}

\begin{frame}<0>[fragile]{Filas Usando Vetores}
\begin{columns}
\column{.5\textwidth}
\begin{itemize}
\item Vetores possuem um espaço limitado para armazenar dados;
\item Necessitamos definir um espaço grande o suficiente para a nossa pilha;
\item Necessitamos de um indicador de qual elemento do vetor é o atual topo da pilha.
\item Incluímos sempre no fim.
\item {\color{red}Fila Cheia!}
\end{itemize}
\column{.5\textwidth}
\begin{center}
\begin{tabular}{| p{.5cm} |p{.5cm}c }
\cline{1-1}
 \cellcolor{SpringGreen} 24 & &\\ \cline{1-1}
\cellcolor{GreenYellow}  89& &\\ \cline{1-1}
\cellcolor{SpringGreen}  12& &\\ \cline{1-1}
\cellcolor{GreenYellow}  4 & &\\ \cline{1-1}
\cellcolor{SpringGreen} 55 & &\\ \cline{1-2}
\cellcolor{GreenYellow} 20 & \multicolumn{1}{|p{.5cm}|} {5} & \\ \cline{1-2}
\end{tabular}
\end{center}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Fila usando Lista Encadeada Modificada}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[queue,on chain] (H) {3};
  \node[list,on chain] (A) [below=of H] {};
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \node[list,on chain] (B) {};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \node[list,on chain] (C) {};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  \draw[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \node[element] (AP) [below=of A] {melão};
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}{Fila usando Lista Encadeada}
 Modelagem funcional
 \begin{itemize}
  \item Inserir dado ao fim da fila (\textit{\textbf{enqueue}}) é \color{blue} $\Theta(1)$ \Large $\smiley$
  \item \color{black} \normalsize Remover dado do início da fila (\textit{\textbf{dequeue}}) é \color{blue} $\Theta(1)$ \Large $\smiley$
  \item \color{black} \normalsize Verificar tamanho da fila é \color{blue}$\Theta(1)$ \Large $\smiley$
 \end{itemize} 
\end{frame}

\begin{frame}[fragile]{Modelagem da Cabeça de Fila Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o primeiro elemento da fila;
\item Necessitamos um ponteiro para o último elemento da fila;
\item Necessitamos um inteiro para indicar quantos elementos a fila possui.
\end{itemize}
\begin{lstlisting}
estrutura Fila {
 Elemento *_primeiro;
 Elemento *_ultimo;
 int _quantidade;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{inicializaFila()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializamos  \_primeiro como nulo;
\item Inicializamos  \_ultimo como nulo;
\item Inicializamos o \_quantidade como ``0'';
\end{itemize}
\begin{lstlisting}
inicializaFila()
inicio
  Fila* novo <- ALOQUE(Fila)
  novo._primeiro <- null;
  novo._ultimo <- null;
  novo._quantidade <- 0;
  RETORNE Fila;
fim;
\end{lstlisting}
\end{frame}

\begin{frame}{Método adiciona(T* dado)}
Ilustração simplificada em \\ 
\center\url{https://www.cs.usfca.edu/~galles/visualization/QueueLL.html}
\end{frame}


\begin{frame}[fragile]{Método \textit{adiciona}}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node<6->[queue] (H) {3};
  \node<1-5>[queue] (H) {2};
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<5->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (C);  
  \draw<1-4>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (B);

  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [above right=of H] {Novo}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1+2,\y2+2) -- (C);  
  
  %primeiro elemento
  \node[list,on chain] (A) [below=of H] {};
  \node[list,on chain] (B) {};
  \node<2->[list,on chain] (C) {};
  %dados 
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (AP) [below=of A] {melão};
  %ponteiros
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  
  
   %segundo elemento
  %dados
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (BP) [below=of B] {maçã}; 
  %ponteiro
  \draw<4->[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw<1-3>[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2-2) .. controls +(north:20mm) and +(up:10mm)  .. (D.north);
  
  %terceiro elemento  
  
  %dados
  \node<2->[element] (CP) [below=of C] {uva};
  \draw<2->[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
   %null pointer
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [right=of C]{null*};
  %ponteiro
  \draw<3->[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{adiciona} - Caso Especial Fila Vazia}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node<1-5>[queue] (H) {0};
  \node<6->[queue] (H) {1};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below right=of H]{null*};
    %primeiro elemento
  \node<2->[list,on chain] (A) [below=of H] {};
  %dados 
  \draw<2->[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node<2->[element] (AP) [below=of A] {melão};
  \draw<1-3>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<1-4>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<3->[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (D);
  \draw<4->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw<5->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (A);
  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of A] {Novo}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{adiciona}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
adiciona(Fila* fila, T* dado)
 Elemento *novo; // auxiliar.
 inicio
  novo <- ALOQUE(Elemento);
  SE ( novo == null) THROW(ERROFILACHEIA);
   SE filaVazia(fila) ENTAO
    fila._primeiro <- novo
   SENAO
    fila._ultimo._proximo <- novo;
   FIM SE
   novo._proximo <- null;
   novo._dado <- dado;
   lista._ultimo <- novo;
   lista._quantidade <- lista._quantidade + 1;
  FIM SE
fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()}}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node<1-2>[queue] (H) {3};
  \node<3->[queue,on chain] (H) {2};

  \node<2-4>[list,draw=blue!60, fill=blue!5,on chain] (S) [below left=of H] {Saiu}; 
  \draw<2-4>[*->] let \p1 = (S.two), \p2 = (S.center) in (\x1,\y2) -- (A);  
  
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (V) [left=of AP] {Volta}; 
  \draw<2->[*->] let \p1 = (V.two), \p2 = (V.center) in (\x1,\y2) -- (AP);  
  
  \node<1-3>[list,on chain] (A) [below=of H] {};
  \draw<1-3>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node<1-4>[element] (AP) [below=of A] {melão};
  \draw<1-3>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  
  \node<3->[list,on chain] (B) [below right=of H] {};
  \node<1-2>[list,on chain] (B) {};
  
  \draw<3->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<1-2>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  
  
  \node[list,on chain] (C) {};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
  \draw<1->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1+2,\y2+2) -- (C);
  
  \node[element] (BP) [below=of B] {maçã}; 
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\begin{itemize}
\item <5-> {\color{red}Semelhanças??}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()} - Caso Especial Fila Unitária}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    queue/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal}, 
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  %cabeca
  \node[queue] (H) {0};
  \node[queue] (H) {1};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) [below right=of H]{null*};
    %primeiro elemento
  \node<1-2>[list,on chain] (A) [below=of H] {};
  %dados 
  \draw<1-2>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (AP) [below=of A] {melão};
  \draw<4->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<4->[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (D);
  \draw<1-2>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (D);
  \draw<1-3>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1,\y2) -- (A);
  \draw<1-3>[*->] let \p1 = (H.three), \p2 = (H.center) in (\x1,\y2) -- (A);
  %novo
  \node<2->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of AP] {Volta}; 
  \draw<2->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (AP);  
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]{Método \textit{T retira()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retira()
 Elemento *saiu; //Variável auxiliar elemento.
 T *volta; //Variável auxiliar tipo T.
 início
  SE (listaVazia()) ENTAO
    THROW(ERROLISTAVAZIA);
  SENAO
    saiu <- _dados;
    volta <- saiu->_info;
    _dados <- saiu->_próximo;
          //Se SAIU for o único, próximo é NULO e está certo.
          SE (_quantidade = 1) ENTAO
           //Fila unitária: devo anular o _fim também.
           _fim <- NULO;
          FIM SE
    _quantidade <- _quantidade - 1;
    LIBERE(saiu);
    RETORNE(volta);
  FIM SE
 fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}{Aplicações de Filas}
 \begin{itemize}
  \item É importante para gerência de dados/processos por ordem cronológica:
  \begin{itemize}
   \item Fila de impressão em uma impressora de rede;
   \item Fila de pedidos de uma expedição ou tele-entrega;
  \end{itemize}
  \item É importante para simulação de processos sequenciais:
  \begin{itemize}
   \item chão de fábrica: fila de camisetas a serem estampadas;
   \item comércio: simulação de fluxo de um caixa de supermercado;
   \item tráfego: simulação de um cruzamento com um semáforo;
  \end{itemize}
  \item Útil para algoritmos de busca em largura.
 \end{itemize}
\end{frame}



\begin{frame}[fragile]{Trabalho Fila Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe Fila todas as operações vistas;
\item Implemente a fila usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Listas Duplamente Encadeadas}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item A Lista Encadeada e a Fila Encadeada possuem a desvantagem de somente podermos caminhar em uma direção:
\begin{itemize}
\item Vimos que para olhar um elemento pelo qual ``acabamos de passar'' precisamos de uma variável auxiliar ``anterior'';
\item Para olhar outros elementos ainda anteriores não temos nenhum meio, a não ser começar de novo.
\end{itemize}
\item A Lista Duplamente Encadeada é uma estrutura de lista que permite deslocamento em ambos os sentidos:
\begin{itemize}
\item Útil para representar conjuntos de eventos ou objetos a serem percorridos em dois sentidos;
\item Útil também quando realizamos uma busca aproximada e nos movemos para a frente e para trás.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lista Duplamente Encadeada}
\setbeamercovered{invisible}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[list,on chain] (H) {3};
  \node[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) {};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};
  
  
  \draw[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);


  \node[element] (AP) [below=of A] {melão};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}[fragile]{Modelagem da Cabeça de Lista Dupla}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o primeiro elemento da lista;
\item Necessitamos um inteiro para indicar quantos elementos a lista possui.
\end{itemize}
\begin{lstlisting}
classe ListaDupla {
 ElementoDuplo *_dados;
 inteiro _tamanho;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Elemento de Lista Dupla}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Estrutural:
\begin{itemize}
\item Necessitamos um ponteiro para o próximo elemento;
\item Necessitamos um ponteiro para o elemento anterior;
\item Necessitamos um ponteiro do tipo da informação que vamos armazenar.
\item T necessita de um destrutor próprio, assim como a lista (neste caso a cabeça) vai precisar de um também;
\end{itemize}
\begin{lstlisting}
classe ElementoDuplo {
 Elemento *_proximo;
 Elemento *_anterior;
 T *_info;
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Aspecto Funcional:
\begin{itemize}
\item Temos que colocar e retirar dados da lista;
\item Temos que testar se a lista está vazia (dentre outros testes);
\item Temos que inicializar a lista e garantir a ordem de seus elementos.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializar ou limpar:
\begin{itemize}
\item ListaDupla();
\item limpaListaDupla();
\item \~{}ListaDupla();
\end{itemize}
\item Testar se a lista está vazia ou cheia e outros testes:
\begin{itemize}
\item bool listaVaziaDupla();
\item int posicaoDupla(dado);
\item bool contemDupla(dado);
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Modelagem da Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Colocar e retirar dados da lista:
\begin{itemize}
\item adicionaDupla(T dado);
\item adicionaNoInicioDupla(T dado);
\item adicionaNaPosicaoDupla(T dado, int posicao);
\item adicionaEmOrdemDupla(T dado);
\item T retiraDupla();
\item T retiraDoInicioDupla();
\item T retiraDaPosicaoDupla(int posicao);
\item T retiraEspecificoDupla(dado);
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{ListaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Inicializamos o ponteiro para nulo;
\item Inicializamos o tamanho para ``0'';
\end{itemize}
\begin{lstlisting}
ListaDupla()
inicio
  _dados = null;
  _tamanho <- 0;
fim;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{\~{}ListaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Chamamos DestroiLista();
\end{itemize}
\begin{lstlisting}
~ListaDupla()
inicio
  DestroiListaDupla();
fim;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{listaVaziaDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{lstlisting}
bool listaVaziaDupla()
inicio
SE (_tamanho = 0) ENTAO
 RETORNE(Verdadeiro)
SENAO
 RETORNE(Falso);
fim;
\end{lstlisting}
\begin{itemize}
\item Um algoritmo ListaCheia não existe na Lista Duplamente Encadeada;\pause
\item Verificar se houve espaço na memória para um novo elemento será responsabilidade de cada operação de adição.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNoInicioDupla(T dado)}}
\setbeamercovered{invisible}
\begin{itemize}
\item Testamos se é possível alocar um elemento;\pause
\item Fazemos o próximo deste novo elemento ser o primeiro;\pause
\item Fazemos a cabeça de lista apontar para o novo elemento.\pause
\end{itemize}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node<10>[list] (H) {3};
  \node<4-9>[list] (H) {2};
  \node<5->[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) [below right=of H]{};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};

  \node<5->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of H] {Novo}; 
  \draw<5->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
  
  
  \draw<9->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<-8>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<6->[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw<7->[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw<8->[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw<-4>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);
  \draw<5-7>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2) .. controls +(south:40mm) and +(down:25mm)  .. (D2.south);


  \node<5->[element] (AP) [below=of A] {melão};
  \draw<5->[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNoInicioDupla(T dado)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\footnotesize
          }
\begin{lstlisting}
adicionaNoInicioDupla(T dado)
 ElementoDuplo *novo; //Variável auxiliar.
 início
  novo <- aloque(ElementoDuplo);
  SE (novo = NULO) ENTAO
   THROW(ERROLISTACHEIA);
  SENAO
   novo->_proximo <- _dados;
   novo->_anterior <- NULO;
   novo->_info <- dado;
   _dados <- novo;
   SE (novo->_proximo ~= NULO) ENTAO
    novo->_proximo->_anterior <- novo;
   FIM SE;
   _tamanho <- _tamanho + 1;
  FIM SE
  fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDoInicioDupla()}}
\setbeamercovered{invisible}
\begin{itemize}
\item Testamos se há elementos;\pause
\item Decrementamos o tamanho;\pause
\item Liberamos a memória do elemento;\pause
\item Devolvemos a informação.\pause
\end{itemize}
\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2,
    draw=green!60, fill=green!5, rectangle split horizontal},
    double/.style={rectangle split, rectangle split parts=3,
    draw=green!60, fill=green!5, rectangle split horizontal},  
    element/.style={rectangle, draw=yellow!60, fill=yellow!5,},    
    >=stealth, start chain]

  \node[list] (H) {3};
  \node<10->[list] (H) {2};
  \node<-8>[double,on chain] (A) [below=of H] {};
  \node[double,on chain] (B) [below right=of H]{};
  \node[double,on chain] (C) {};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D) {null*};
  \node[on chain,draw=red!60, fill=red!5,inner sep=6pt] (D2)[left=of A] {null*};

  \node<6->[list,draw=blue!60, fill=blue!5,on chain] (N) [left=of H] {Saiu}; 
  \draw<6->[*->] let \p1 = (N.two), \p2 = (N.center) in (\x1,\y2) -- (A);  
  \node<6->[list,draw=blue!60, fill=blue!5,on chain] (V) [left=of AP] {Volta}; 
  \draw<6->[*->] let \p1 = (V.two), \p2 = (V.center) in (\x1,\y2) -- (AP);  
  
  
  \draw<-7>[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (A);
  \draw<8->[*->] let \p1 = (H.two), \p2 = (H.center) in (\x1+2,\y2+2) -- (B);
  \draw<-8>[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2+2) -- (B);
  \draw<-8>[*->] let \p1 = (A.one), \p2 = (A.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (B.three), \p2 = (B.center) in (\x1,\y2+2) -- (C);
  \draw<-6>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (A);
  \draw<9->[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+4,\y2-2) -- (D2);
  \draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2+2) -- (D);
  \draw[*->] let \p1 = (C.one), \p2 = (C.center) in (\x1+4,\y2-2) -- (B);
  \draw<7-8>[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1+2,\y2) .. controls +(south:40mm) and +(down:25mm)  .. (D2.south);


  \node[element] (AP) [below=of A] {melão};
  \draw<-8>[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1+2,\y2+2) -- (AP);
  \node[element] (BP) [below=of B] {maçã};
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1+2,\y2+2) -- (BP);
  \node[element] (CP) [below=of C] {uva};
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1+2,\y2+2) -- (CP);
 
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDoInicioDupla()}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retiraDoInicioDupla()
 ElementoDuplo *saiu; //Variável auxiliar elemento.
 T *volta; //Variável auxiliar tipo T.
 início
  SE (listaVaziaDupla()) ENTAO
    THROW(ERROLISTAVAZIA);
  SENAO
    saiu <- _dados;
    volta <- saiu->_info;
    _dados <- saiu->_proximo;
    SE (_dados ~= NULO) ENTAO
   dados->_anterior <- NULO;
    FIM SE
    _tamanho <- _tamanho - 1;
    LIBERE(saiu);
    RETORNE(volta);
  FIM SE
 fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNaPosicaoDupla(T dado, int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Praticamente idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Caminhamos até a posição;
\item Adicionamos o novo dado na posição;
\item Tratamos o caso especial;
\item Incrementamos o tamanho.
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item O dado a ser inserido;
\item A posição onde inserir;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaNaPosicaoDupla(T dado, int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
adicionaNaPosicaoDupla(T dado, int posicao)
 ElementoDuplo *novo, *anterior; // auxiliares.
 inicio
  SE (posicao > _tamanho + 1) ENTAO THROW(ERROPOSICAO);
  SENAO
   SE (posicao = 1) ENTAO RETORNE(adicionaNoInícioDupla(info));
   SENAO
    novo <- aloque(ElementoDuplo); 
    SE (novo = NULO) ENTÃO THROW(ERROLISTACHEIA);
    SENAO
     anterior <- _dados;
     REPITA (posicao - 2) VEZES anterior <- anterior->_proximo;
     novo->_proximo <- anterior->_proximo;
     SE (novo->_proximo ~= NULO) ENTAO  
      novo->_proximo->_anterior <- novo; 
     novo->_info <- info;
     anterior->_proximo <- novo;
     _tamanho <- _tamanho + 1;
    FIM SE
   FIM SE
  FIM SE
fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDaPosicaoDupla(int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Praticamente idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Caminhamos até a posição;
\item Retiramos o novo dado na posição;
\item Tratamos o caso especial;
\item Decrementamos o tamanho.
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item A posição onde retirar;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Método \textit{T retiraDaPosicaoDupla(int posicao)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          escapeinside={(*@}{@*)},
          basicstyle=\ttfamily\scriptsize
          }
\begin{lstlisting}
T retiraDaPosicaoDupla(int posicao)
 ElementoDuplo *anterior, *eliminar; //Variáveis elemento.
 T *volta; //Variável tipo T.
 inicio
  SE (posicao > _tamanho ) ENTAO THROW(ERROPOSICAO);
  SENAO
   SE (posicao = 1) ENTAO RETORNE(retiraDoInicioDupla());
   SENAO
    anterior <- _dados;
    REPITA (posicao - 2) VEZES 
      anterior <- anterior->_proximo;
    eliminar <- anterior->_proximo;
    volta <- eliminar->_info;
    anterior->_proximo <- eliminar->_proximo;
    SE eliminar->_proximo ~= NULO ENTAO
     eliminar->_proximo->_anterior <- anterior;
    _tamanho <- _tamanho - 1;
    LIBERE(eliminar);  RETORNE(volta);
   FIM SE
  FIM SE
 fim;
(*@  \textcolor{red}{}  @*)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Método \textit{adicionaEmOrdemDupla(T dado)}}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Idêntico à lista encadeada;
\item Procedimento:
\begin{itemize}
\item Necessitamos de uma função para comparar os dados ``>'';
\item Procuramos pela posição onde inserir comparando dados;
\item Chamamos adicionaNaPosiçãoDupla().
\end{itemize}
\item Parâmetros:
\begin{itemize}
\item O dado a ser inserido;
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Por conta do aluno:}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }

\begin{itemize}
\item Operações de inclusão e exclusão:
\begin{itemize}
\item AdicionaDupla(dado);
\item RetiraDupla();
\item RetiraEspecíficoDupla(dado);
\end{itemize}
\item Operações - inicializar ou limpar:
\begin{itemize}
\item DestróiListaDupla();
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Trabalho Lista Duplamente Encadeada}
\lstset{language=C++,
          keywordstyle=\color{blue}\ttfamily,
          stringstyle=\color{red}\ttfamily,
          commentstyle=\color{OliveGreen}\ttfamily,
          breaklines=true,
          basicstyle=\ttfamily\footnotesize
          }
\begin{itemize}
\item Implemente uma classe ListaDupla todas as operações vistas;
\item Implemente a lista usando Templates;
\item Use as melhores práticas de orientação a objetos;
\item Documente todas as classes, métodos e atributos;
\item Aplique os testes unitários disponíveis no moodle da disciplina para validar sua estrutura de dados;
\item Entregue até a data definida no moodle.
\end{itemize}
\end{frame}

{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_capa.png}}
\begin{frame}

{\LARGE Perguntas????}

\end{frame}
}


{
\usebackgroundtemplate{\includegraphics[width=\paperwidth,
height=\paperheight]{../reusable_images/fundo_capa.png}}
\begin{frame}
\includegraphics[scale=0.8]{../reusable_images/cc_logo_arge.png}\hspace{0.5cm}
\includegraphics[scale=0.95]{../reusable_images/by.png}

\vspace{1cm}
Este trabalho está licenciado sob uma Licença Creative Commons Atribuição 4.0 Internacional. Para ver uma cópia desta licença, visite http://creativecommons.org/licenses/by/4.0/.

\end{frame}
}
\end{document}
